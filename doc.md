# 一些算法说明

## 符号说明

| 说明                   | 符号  |
|----------------------|-----|
| 原始数据包个数              | M   |
| 第i个原始数据包             | Xi  |
| 生成喷泉码数据包个数           | N   |
| 第i个喷泉码数据包            | Yi  |
| 第i个喷泉码数据包所包含的原始数据包个数 | Ki  |
|                      |     |

## 理论地址空间
对于每条300n的DNA链，大约可以映射存储60byte的数据，其中包括4Byte的地址Seed和56Byte的数据包。那么理论数值空间大小就为
$$
56B * 2^{32} / 2= 112GB = 896Gb
$$
注：/2是因为地址空间存储的是喷泉码的序号，按照2倍喷泉码而设计



## DNA映射算法

考虑到整体对CG含量以及连续相同碱基的限制，下面设计了基于上文统计的动态DNA算法。整体假设比特流各个位置是均匀分布的。

在DNA编码的过程中，我们会记录前两个已经编码的碱基，同时统计已经编码的CG和AT数量，以此为基础生成针对下一个碱基的映射表。映射表包括两部分：当前两个碱基相同时，为避免下一个碱基相同，则需要根据查表插入对应的碱基（对）；当碱基不同时，需要根据一个伪随机算法得到2个bit对应1个碱基的映射，这个映射会随着当前已编码数量而动态改变。

### CG含量控制

算法会实时统计当前已编码的CG含量，当CG含量过大时会影响碱基相同时映射表的选择，以此来达到宏观控制碱基含量的目的。可以设置不同的阈值（CG含量/AT含量）以控制最后大致的CG实际含量。

### 碱基不同时

```python
def dynamic_mapping(value) -> str:
  index = (self.CGCount + self.ATCount) // 7 % 19 % 4
  keys = "ACTG"
  return keys[(index + value) % 4]
```

设计了一个伪随机数算法以达到一定的随机映射效果。根据当前编码的总数，进行一定的计算偏移得到映射表，将0123一一映射到ACTG

### 碱基相同时

```python
 ATMap = {
   "A": ["TA", "TC", "TT", "TG"],
   "C": ["TA", "TC", "AT", "TG"],
   "T": ["AA", "AC", "AT", "AG"],
   "G": ["AT", "AC", "TA", "TG"]
 }
  CGMap = {
    "A": ["CA", "GC", "CT", "CG"],
    "C": ["GA", "GC", "GT", "GG"],
    "T": ["GA", "GC", "GT", "CG"],
    "G": ["CA", "CC", "CT", "CG"]
  }
```

当前两个碱基相同时，为避免下一个碱基相同，则需要根据查表插入对应的碱基（对）。同时根据当前CG含量的情况，选择更多AT的ATMap或者更多CG的CGMap进行映射。在解码时也会进行同样的操作以正确解码。





## 关于Seed

在lt喷泉码中需要两个参数才可以确定数据包是由哪几个原始数据包所构成的。一个是此数据包的需要，另一个是原始数据包的个数。

在生成数据包ENCODE时，首先会初始化一个指定长度N的抽样分布，然后根据数据包的序号i，取到对应的需要在这个数据包中包含多少个原始数据包的个数Ki。下一步则使用这个序号i作为python.random的seed，在M中抽取Ki个序号，那么Yi就由这Ki个对应的原始数据包构成。

在解码阶段则先使用Yi的序号i作为seed，然后在M中抽取Ki个序号，进行解码。

这样的方案需要存储两个数值作为包，占用空间较大。所以进行改进使之只使用一个index生成所有数据。

首先在编码阶段，使用M作为Seed，生成长度为2M的抽样分布。因为这2M可能比N小，所以i在获取自己需要抽样多少个包时，使用 i % 2M 作为对应的序号得到对应的Ki。而M会作为唯一的参数存储在第一个DNA链中。

在解码阶段，在获取到M之后，再生成长度为2M的抽样分布，然后同样的方法获取Ki。最后完成解码。



## 投票校验

在DNA->比特流解码之后，需要判断DNA以及比特流是否有损坏。传统的方法是在比特流的固定位置加入一定长度的校验码，在解码后使用校验码对这段比特流进行校验，但是由于校验码的长度限制，并不能百分百的保证数据的准确性，同时考虑到在进行DNA存储时会进行大量的PCR扩增以及重复的DNA读取，所以考虑采用投票的方式进行校验。

投票即将具有重复index的多条序列进行比较，因为大多数序列是完好的，而即使出错的序列也会是随机出错的，所以可以认为完全重复最多的序列即为完好的序列。

为了节省计算时间，可以先计算每个序列的MD5值，以MD5代替数据的内容，然后将具有相同MD5值的序列分成一组。组里面最多的一个组就认为是正确的组。

在进行投票之前，可以先对数据的长度进行确认，先过滤掉长度不正确的序列。所以投票校验也有没有正确结果的可能，但是根据喷泉码的设计，直接丢弃即可。
