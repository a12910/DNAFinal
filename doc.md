# 一些算法说明

## 符号说明

| 说明                   | 符号  |
|----------------------|-----|
| 原始数据包个数              | M   |
| 第i个原始数据包             | Xi  |
| 生成喷泉码数据包个数           | N   |
| 第i个喷泉码数据包            | Yi  |
| 第i个喷泉码数据包所包含的原始数据包个数 | Ki  |
|                      |     |

## 理论地址空间
对于每条300n的DNA链，大约可以映射存储60byte的数据，其中包括4Byte的地址Seed和56Byte的数据包。那么理论数值空间大小就为
$$
56B * 2^{32} / 2= 112GB = 896Gb
$$
注：/2是因为地址空间存储的是喷泉码的序号，按照2倍喷泉码而设计



## DNA映射算法

考虑到整体对CG含量以及连续相同碱基的限制，下面设计了基于上文统计的动态DNA算法。整体假设比特流各个位置是均匀分布的。

在DNA编码的过程中，我们会记录前两个已经编码的碱基，同时统计已经编码的CG和AT数量，以此为基础生成针对下一个碱基的映射表。映射表包括两部分：当前两个碱基相同时，为避免下一个碱基相同，则需要根据查表插入对应的碱基（对）；当碱基不同时，需要根据一个伪随机算法得到2个bit对应1个碱基的映射，这个映射会随着当前已编码数量而动态改变。

### CG含量控制

算法会实时统计当前已编码的CG含量，当CG含量过大时会影响碱基相同时映射表的选择，以此来达到宏观控制碱基含量的目的。可以设置不同的阈值（CG含量/AT含量）以控制最后大致的CG实际含量。

### 碱基不同时

```python
def dynamic_mapping(value) -> str:
  index = (self.CGCount + self.ATCount) // 7 % 19 % 4
  keys = "ACTG"
  return keys[(index + value) % 4]
```

设计了一个伪随机数算法以达到一定的随机映射效果。根据当前编码的总数，进行一定的计算偏移得到映射表，将0123一一映射到ACTG

### 碱基相同时

```python
 ATMap = {
   "A": ["TA", "TC", "TT", "TG"],
   "C": ["TA", "TC", "AT", "TG"],
   "T": ["AA", "AC", "AT", "AG"],
   "G": ["AT", "AC", "TA", "TG"]
 }
  CGMap = {
    "A": ["CA", "GC", "CT", "CG"],
    "C": ["GA", "GC", "GT", "GG"],
    "T": ["GA", "GC", "GT", "CG"],
    "G": ["CA", "CC", "CT", "CG"]
  }
```

当前两个碱基相同时，为避免下一个碱基相同，则需要根据查表插入对应的碱基（对）。同时根据当前CG含量的情况，选择更多AT的ATMap或者更多CG的CGMap进行映射。在解码时也会进行同样的操作以正确解码。



## 关于Seed

在lt喷泉码中需要两个参数才可以确定数据包是由哪几个原始数据包所构成的。一个是此数据包的需要，另一个是原始数据包的个数。

在生成数据包ENCODE时，首先会初始化一个指定长度N的抽样分布，然后根据数据包的序号i，取到对应的需要在这个数据包中包含多少个原始数据包的个数Ki。下一步则使用这个序号i作为python.random的seed，在M中抽取Ki个序号，那么Yi就由这Ki个对应的原始数据包构成。

在解码阶段则先使用Yi的序号i作为seed，然后在M中抽取Ki个序号，进行解码。

这样的方案需要存储两个数值作为包，占用空间较大。所以进行改进使之只使用一个index生成所有数据。

首先在编码阶段，使用M作为Seed，生成长度为2M的抽样分布。因为这2M可能比N小，所以i在获取自己需要抽样多少个包时，使用 i % 2M 作为对应的序号得到对应的Ki。而M会作为唯一的参数存储在第一个DNA链中。

在解码阶段，在获取到M之后，再生成长度为2M的抽样分布，然后同样的方法获取Ki。最后完成解码。



## 投票校验

在DNA->比特流解码之后，需要判断DNA以及比特流是否有损坏。传统的方法是在比特流的固定位置加入一定长度的校验码，在解码后使用校验码对这段比特流进行校验，但是由于校验码的长度限制，并不能百分百的保证数据的准确性，同时考虑到在进行DNA存储时会进行大量的PCR扩增以及重复的DNA读取，所以考虑采用投票的方式进行校验。

投票即将具有重复index的多条序列进行比较，因为大多数序列是完好的，而即使出错的序列也会是随机出错的，所以可以认为完全重复最多的序列即为完好的序列。

为了节省计算时间，可以先计算每个序列的MD5值，以MD5代替数据的内容，然后将具有相同MD5值的序列分成一组。组里面最多的一个组就认为是正确的组。

在进行投票之前，可以先对数据的长度进行确认，先过滤掉长度不正确的序列。所以投票校验也有没有正确结果的可能，但是根据喷泉码的设计，直接丢弃即可。



## 投票检验的公式推导

https://blog.csdn.net/LuohenYJ/article/details/78766950

简单投票法：若一个初始DNA链复制为n个复制DNA链，且存在超过半数的完全相同的DNA链，则视为这个DNA链结果等于初始DNA链，否则视为不存在正确的初始DNA链。

考虑最简单的仅一种出错的模型，即对于DNA链x，经过复制过程f(x)以概率1-p使得f(x)=x，p概率为f(x)=其他
$$
P(f(x)≠x)= 1 - p > \frac 12
$$
则对于使用简单投票法和N个复制DNA链，令$H(N)$为正确的链数，每个链正确的概率为$p>\frac 12$，若要分类错误则有
$$
H(N) < [\frac N2]
$$
下面证明分类错误率会随着N增大而指数级减少



证明：由Hoeffding不等式

> 若硬币正面朝上概率为p，反面朝上概率$1-p=q$，令$H(n)$为抛硬币n次硬币所得正面朝上的次数，则最多k次正面朝上的概率为：

$$
P(H(n)≤k)=\sum_{i=0}^kC_n^ip^i(1-p)^{n-i}
$$
> 若 $\forall \delta>0, K=(p-\delta)n$，则有：

$$
P[H(n)≤(p-\delta)n]≤e^{-2\delta^2n}
$$
回到DNA

若要错误分类率 $P[H(N)≤[\frac N2]]>0.5$(即至少$[N/2]$个DNA错误)，应该满足公式： 
$$
\forall \delta > 0,  P[H(N)≤(p-\delta)N]≤e^{-2\delta^2N}
$$
令$(p-\delta)N = [\frac N2]$，所以有
$$
\delta = p-\frac1N[\frac N2]≥p-\frac 12=\frac{2p-1}2
$$
而 $\forall \delta>0$ 所以
$$
p-\frac 1N[\frac N2]≥0
$$
当$\delta=\frac{2p-1}2$有
$$
P[H(N)≤[\frac N2]]=\sum_{i=0}^{\frac N2}C_n^ip^i(1-p)^{N-i}≤e^{-2(\frac{2p-1}2)^2N}=e^{-\frac N2(2p-1)^2}
$$
故当N变大时，基于简单投票的DNA分类错误率会以指数级趋于0

当错误种类远大于1时，由于投票本身的性质，多个错误DNA链中具有最多相同链的DNA种类的数量一定是小于仅有一种错误链的数量，所以可以认为其分类错误率会更小。



## 映射Codebook设计限制

动态Codebook指对于考虑前两个编码碱基以及全局的统计量，生成从0123对下一个编码碱基的映射。在设计上可以根据当前整体的状态，设计不同的映射表，以达到对整体的控制。

- 如当CG含量高于阈值时，可以控制增加Codebook中AT的含量，使接下来输出的AT含量更大。对CG含量的控制能力可以由生成链中的CG含量与指定阈值的平方误差确定。

- 如若要保证（一定概率p）不含连续的3个碱基，那么在当前两个碱基相同的时候，需要生成特定的codebook，使得下一个碱基一定不同于前两个碱基。对连续碱基的控制能力可以由链中连续碱基的长度比例与p的误差确定。

- 若要使整体压缩率更小（bit/碱基更大），那么需要codebook中尽可能保证 0123对应碱基长度的期望更小
  $$
  f(n \in 0,1,2,3) \rightarrow \{A,C,T,G,AA,AC...\} \\length = \sum_{n \in 0,1,2,3}p(n)*len(f(n))
  $$

- 在数据中经常会出现连续的重复数据，那么就需要增加codebook的随机性，以保证当出现连续重复的bit时也可以生成较为无规律且高压缩率的DNA流。为此仿照伪随机数的生成，设计了一种基于位置的动态codebook，当前两个编码碱基不同时，使用这样的映射规律进行0123到ACTG的一一映射。

  ```python
  def dynamic_mapping(value) -> str:
      index = (self.CGCount + self.ATCount) // 7 % 19 % 4
      keys = "ACTG"
      return keys[(index + value) % 4]
  ```

$$
偏移 = [\frac {len(已编码长度)}7] \ mod \ 19 \\
$$

$$
f(x \in \{0,1,2,3\}) = \{A, C, T, G\}[x位置+偏移]
$$

- 举例：bit流 64位0
  - 不使用动态映射：AACAACAA CAACAACA ACAACAAC AACAACAA CAACAACA ACAACAA
  - 使用动态映射：AACAACAC CGACCTAT TGATTGAG GCAGAACA ACACCGAC CTA



## Map举例

| 序号 | 平均长度 | CG含量                        |
| ---- | -------- | ----------------------------- |
| 0    | 293      | 0.445 0.473 0.475 0.478 0.504 |
| 1    | 266      | 0.401 0.471 0.481 0.496 0.542 |
| 2    | 257      | 0.446 0.484 0.495 0.510 0.555 |
| 3    | 247      | 0.390 0.460 0.476 0.488 0.516 |

